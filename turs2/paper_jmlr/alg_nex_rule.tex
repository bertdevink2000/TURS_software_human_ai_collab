%\begin{algorithm}[h] 
%\DontPrintSemicolon
%% \tcp{CUTS: candidate cuts for all dimensions}
%  \KwInput{(Incomplete) rule set $\tilde{M}$, data $(x^n, y^n)$}
%  \KwOutput{The next best rule $S^*$}
%%  \textbf{INPUT:} RULESET, $(x^n, y^n)$;   \textbf{OUTPUT:} RULE; 
%  
%  RULE $\assign$ $\emptyset$; Beam $\assign$ [RULE] \tcp*{Initialize the empty rule and beam}
%%  \tcp*{initialized as an empty array}
%  
%%  \tcp*{initial beam}
%  
%  BeamList $\assign$ Beam \tcp*{Record all the beams in the beam search}
%  
%%  $w = 5$ \tcp*{beam width}
%%  \While{TRUE}
%\While{$\operatorname{length}(Beam)  \neq 0$}
%  {
%    candidates $\assign$ [ ] \tcp*{initialized to store all possible refinements}
%
%    \For {RULE $\in$ Beam}     
%    {
%        Rs $\assign$ [Append L to RULE for L $\in$ all possible literals] 
%        
%        candidates.extend(Rs)
%    }
%    
%    Beam $\assign$ the $w$ rules in candidates that have 1) the highest positive $g_{unc}()$, and 2) coverage diversity $> \alpha$ \tcp*{$w$ is the beam width}
%    
%    \If {$\operatorname{length}$(Beam) $ \neq 0$}
%    {    
%        BeamList.extend(Beam) \tcp*{extend the BeamList as an array}
%    }
%    
%  }
%  
%  \For{Rule $\in$ BeamList}
%  {
%    Beam $\assign$ $w$ rules in BeamList with best $L_{\mathcal{T}}(\ruleset \oplus S_{unc})$ 
%  }
% \Return{Beam}
%\caption{Find Next Rule}
%\label{alg:find_next_rule}
%\end{algorithm}	

\begin{algorithm}[ht]
\caption{Find Next Rule} \label{alg:find_next_rule}
\begin{algorithmic}[1]
\REQUIRE (Incomplete) rule set $\tilde{M}$, dataset $(x^n, y^n)$, beam width $W$;
\ENSURE The next rule $S$, potentially to be added to $\tilde{M}$;
\STATE $\text{All\_candidate\_rules} \leftarrow \text{Empty Array}$
\STATE $\text{rules\_for\_next\_iter} \leftarrow \text{[Empty Rule]}$ \COMMENT{Initialize the rule with an ``empty" condition}
\WHILE{TRUE}
	\STATE $\text{beam} \leftarrow \text{EmptyBeam}()$ \COMMENT{Initialize the beam for the beam search}
	\STATE $\text{auxiliary\_beam} \leftarrow \text{EmptyBeam}()$ \COMMENT{Initialize the auxiliary beam  (Section~\ref{subsec:auxiliary_beam}})
	\FOR{$\text{rule}$ in $\text{rules\_for\_next\_iter}$}
		\STATE $\text{rule\_candidates} \leftarrow \text{generate\_candidates}(\text{rule})$
		\STATE $\text{categorized\_candidates} \leftarrow \text{categorize}(\text{rule\_candidates})$ \COMMENT{categorize candidates into subgroups by their coverage (Section~\ref{subsec:diverse_beam_search})}
		\STATE $\text{best\_W\_candidates} \leftarrow \text{candidate} \in \text{categorized\_candidates satisfying the }$ 
		\STATE $\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, \text{ \textbf{local constraint} with the best }  r(candidate) \text{ in each category}$ 
		\COMMENT{local constraint is defined in Section~\ref{subsec:local_constraint}; r(.) defined in Equation~\ref{eq:learning_rate}}
		
		\STATE $\text{categorized\_candidates\_auxiliary} \leftarrow \text{categorize}(\text{rule\_candidates})$ \COMMENT{categorize candidates into subgroups by their coverage excluding the instances covered by $\title{M}$ (Section~\ref{subsec:diverse_beam_search})}
		\STATE $\text{best\_W\_auxiliary} \leftarrow \text{ candidate} \in \text{categorized\_candidates\_auxiliary satisfying}$
		\STATE $\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\, \text{ \textbf{local constraint} with the best }  R(candidate) \text{ in each category}$  \COMMENT{R(.) defined in Equation~\ref{eq:surrogate_learning_rate}}
		\STATE $\text{update\_beam} (\text{beam}, \text{best\_W\_candidates})$ \COMMENT{update using r(.)}
		\STATE $\text{update\_beam} (\text{auxiliary\_beam}, \text{best\_W\_auxiliary})$ \COMMENT{update using R(.)}
	\ENDFOR
	\STATE $\text{stop} \leftarrow \text{check\_whether\_stop}()$
	\IF{$\text{stop}$}
		\STATE $\text{among all } S \in \text{All\_candidate\_rules}$
		\RETURN \text{the S with the largest } r(S)
	\ELSE
		\STATE $\text{All\_candidate\_rules.append(beam)}$
		\STATE $\text{rules\_for\_next\_iter} \leftarrow \text{beam} \cup \text{auxiliary\_beam}$
	\ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}

